package com.ccb.def;

/**
 * 二叉排序树：
 *  默认没有重复项。如果有，可以封装节点，使之记录出现次数。
 *  一、基础操作：
 *  1、查找、新增：类二分法
 *  2、删除：
 *      1、没有左右子树，直接删
 *      2、只有一边，直接接上去
 *      3、左右子树存在：
 *          选择左子树[右子树]，向右[左]找端点New，代替删除节点。然后将New的左子树[右子树]接到New的位置
 *          概括：找次小或次大代替
 *  3、旋转：
 *      左旋：右子树的左指针指向当前节点，右子树的左孩子为当前节点的右孩子
 *      右旋：左子树的右指针指向当前节点，左子树的右孩子为当前节点的左孩子
 *
 *  二、分类(平衡性判断标准不同)：
 *      1、AVL[高度]：
 *      2、SB树[Size]：
 *      3、红黑树[颜色]：
 *
 *      关系：
 *          BST<左右旋的BST<AVL/红黑树/SB树
 */
public class BinarySearchTree {

    /**
     * 平衡二叉树AVL：高度差不超过1
     *  检测时机：每次变化都要自底向上检查
     *  破坏平衡的4种情况：
     *  1、LL：右旋
     *  2、RR：左旋
     *  3、LR：左子树左旋[左子树的右子节点成为顶点]，整体右旋
     *  4、RL：右子树右旋[右子树的左子节点成为顶点]，整体左旋
     */
    static class BalancedBinaryTree {

    }

    /**
     * SB树：每棵叔叔树的大小，不小于任何侄子树(兄弟节点的子树)的大小
     * 检测时机：每次变化时，变化结构的节点进行递归
     * 破坏平衡的4种情况：同上。在旋转完毕后，还要递归改变结构的节点，重新判断(保险)
     */
    static class SizeBalancedTree {

    }

    /**
     * 红黑树
     * 特点：
     *  1、节点 要么黑要么红
     *  2、根节点/叶子节点[空节点]为黑
     *  3、红节点不能相邻
     *  4、当前节点到每一个叶子节点经过的黑节点数量一样
     */
    static class RedBlackTree {

    }

}
